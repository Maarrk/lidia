function [data] = pack_lidia(north_m, east_m, down_m, ...
    roll_rad, pitch_rad, yaw_rad, ...
    vx_mps, vy_mps, vz_mps, ...
    vn_mps, ve_mps, vd_mps, ...
    ctrl_sr, ctrl_sp, ctrl_thr, ctrl_pr, ctrl_coll, ...
    trgt_sr, trgt_sp, trgt_thr, trgt_pr, trgt_coll, ...
    t_boot_ms)
%PACK_LIDIA Pack aircraft state into binary format
%   The output is an array of 172 bytes in MsgPack format, as expected by 'smol' source of lidia package.
%   The relevant keys are always encoded, and are replaced with provided arguments.
%   This is done to avoid using collection.Map, structs etc. which do not play nicely with Simulink
%
%   Arguments:
%       north_m, east_m, down_m: Position in local horizon coordinate system, in meters
%       roll_rad, pitch_rad, yaw_rad: Aircraft attitude, in radians
%       vx_mps, vy_mps, vz_mps: Velocity in body frame, in meters per second
%       vn_mps, ve_mps, vd_mps: Velocity in local horizon coordinate system, in meters per second
%       ctrl_*: Current control inceptors position
%       trgt_*: Target inceptors position
%           *_sr: Control stick input to roll right, between -1 and 1
%           *_sp: Control stick input to pitch up, between -1 and 1
%           *_thr: Engine power input, between 0 and 1
%           *_pr: Pedals input to yaw right, between -1 and 1
%           *_coll: Collective input to increase lift, between 0 and 1
%       t_boot_ms: Time from the start of simulation, in milliseconds

data = [ % template msgpack message
    0x87, 0xA3, 0x6E, 0x65, 0x64, 0x93, 0xCB, 0x3F, ...
    0xB9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9A, 0xCB, ...
    0x3F, 0xC9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9A, ...
    0xCB, 0x3F, 0xD3, 0x33, 0x33, 0x33, 0x33, 0x33, ...
    0x33, 0xA3, 0x61, 0x74, 0x74, 0x93, 0xCA, 0x3D, ...
    0xCC, 0xCC, 0xCD, 0xCA, 0x3E, 0x4C, 0xCC, 0xCD, ...
    0xCA, 0x3E, 0x99, 0x99, 0x9A, 0xA6, 0x76, 0x5F, ...
    0x62, 0x6F, 0x64, 0x79, 0x93, 0xCA, 0x3D, 0xCC, ...
    0xCC, 0xCD, 0xCA, 0x3E, 0x4C, 0xCC, 0xCD, 0xCA, ...
    0x3E, 0x99, 0x99, 0x9A, 0xA5, 0x76, 0x5F, 0x6E, ...
    0x65, 0x64, 0x93, 0xCA, 0x3D, 0xCC, 0xCC, 0xCD, ...
    0xCA, 0x3E, 0x4C, 0xCC, 0xCD, 0xCA, 0x3E, 0x99, ...
    0x99, 0x9A, 0xA4, 0x63, 0x74, 0x72, 0x6C, 0x95, ...
    0xCA, 0x3D, 0xCC, 0xCC, 0xCD, 0xCA, 0x3E, 0x4C, ...
    0xCC, 0xCD, 0xCA, 0x3E, 0x99, 0x99, 0x9A, 0xCA, ...
    0x3E, 0xCC, 0xCC, 0xCD, 0xCA, 0x3F, 0x00, 0x00, ...
    0x00, 0xA4, 0x74, 0x72, 0x67, 0x74, 0x95, 0xCA, ...
    0x3D, 0xCC, 0xCC, 0xCD, 0xCA, 0x3E, 0x4C, 0xCC, ...
    0xCD, 0xCA, 0x3E, 0x99, 0x99, 0x9A, 0xCA, 0x3E, ...
    0xCC, 0xCC, 0xCD, 0xCA, 0x3F, 0x00, 0x00, 0x00, ...
    0xA6, 0x74, 0x5F, 0x62, 0x6F, 0x6F, 0x74, 0xCE, ...
    0x13, 0x37, 0xCA, 0xFE
    ];

data = float64_triple(data, 0x05, north_m, east_m, down_m);
data = float32_triple(data, 0x25, roll_rad, pitch_rad, yaw_rad);
data = float32_triple(data, 0x3C, vx_mps, vy_mps, vz_mps);
data = float32_triple(data, 0x52, vn_mps, ve_mps, vd_mps);
data = float32_quintuple(data, 0x67, ...
    ctrl_sr, ctrl_sp, ctrl_thr, ctrl_pr, ctrl_coll);
data = float32_quintuple(data, 0x86, ...
    trgt_sr, trgt_sp, trgt_thr, trgt_pr, trgt_coll);
data(0xA9:0xAC) = scalar2bytes(uint32(t_boot_ms));

end

% offset is the index of first array byte, zero-indexed
% it has value 0x93 (3-element array), or 0x95 (5-element array)

function out = float64_triple(buffer, offset, x, y, z)
buffer(offset+3:offset+10) = scalar2bytes(double(x));
buffer(offset+12:offset+19) = scalar2bytes(double(y));
buffer(offset+21:offset+28) = scalar2bytes(double(z));
out = buffer;
end

function out = float32_triple(buffer, offset, x, y, z)
buffer(offset+3:offset+6) = scalar2bytes(single(x));
buffer(offset+8:offset+11) = scalar2bytes(single(y));
buffer(offset+13:offset+16) = scalar2bytes(single(z));
out = buffer;
end

function out = float32_quintuple(buffer, offset, p, q, r, s, t)
buffer(offset+3:offset+6) = scalar2bytes(single(p));
buffer(offset+8:offset+11) = scalar2bytes(single(q));
buffer(offset+13:offset+16) = scalar2bytes(single(r));
buffer(offset+18:offset+21) = scalar2bytes(single(s));
buffer(offset+23:offset+26) = scalar2bytes(single(t));
out = buffer;
end

% https://github.com/bastibe/matlab-msgpack
% Used under BSD-3 clause license
function bytes = scalar2bytes(value)
% reverse byte order to convert from little endian to big endian
bytes = typecast(swapbytes(value), 'uint8');
end
